#version 330

flat in vec3 gs_objectPosition;
// Contains voxel-code, material-code and mip-map level
flat in ivec3 gs_voxel_material_mipmap;
in vec3 gs_texCoord;
out vec4 fragColor;
uniform isampler2DArray u_componentTex;

#include "material.glsl"
#include "globalubo.glsl"

// Standard linear congruential generator to hash an integer
int hash(int i)
{
	return i * 1103515245 + 12345;
}

layout(std140) uniform Object
{
	mat4 c_mWorldView;
	mat4 c_mInverseWorldView;
	vec4 c_vCorner000;
	vec4 c_vCorner001;
	vec4 c_vCorner010;
	vec4 c_vCorner011;
	vec4 c_vCorner100;
	vec4 c_vCorner101;
	vec4 c_vCorner110;
	vec4 c_vCorner111;
	float c_fMaxOffset;
};

void main()
{
	// Determine which voxels can be sampled at all (dependent on neighborhood)
	int voxelMask = 0x40 | ((~gs_voxel_material_mipmap.x) & 0x3f);
	int materialIndex = gs_voxel_material_mipmap.x >> 24;
	ivec2 codes;
	codes.x = gs_voxel_material_mipmap.y;

	// Find view direction in component-space
	vec3 chunkSpacePos = gs_objectPosition + gs_texCoord - 0.5;
	vec3 viewDir = normalize((vec4(chunkSpacePos, 1) * c_mWorldView).xyz);
	vec3 chunkSpaceDir = viewDir * mat3x3(c_mInverseWorldView);
	
	// Number of pixel must be equal in all directions (can theoretically be changed
	// if required). Used for ray marching the texture.
	int texSize = 16 / (1 << gs_voxel_material_mipmap.z);
	
	// Initialize ray marching algorithm
	ivec3 dirSign; 
	dirSign.x = chunkSpaceDir.x < 0.0f ? -1 : 1;
	dirSign.y = chunkSpaceDir.y < 0.0f ? -1 : 1;
	dirSign.z = chunkSpaceDir.z < 0.0f ? -1 : 1;
	vec3 voxelPos = gs_texCoord * (texSize - 0.00001);
	ivec3 rayPos = ivec3(voxelPos);
	vec3 absDir = abs(chunkSpaceDir);
	vec3 projLength = 1.0 / (absDir + 0.0001);
	vec3 d = voxelPos - rayPos;
	if(dirSign.x == 1) d.x = 1-d.x;
	if(dirSign.y == 1) d.y = 1-d.y;
	if(dirSign.z == 1) d.z = 1-d.z;
	d *= projLength;
	
	if( materialIndex != 0 && texSize > 1 )
	{
		// Ray march until a voxel is set in the current configuration
		codes = texelFetch(u_componentTex, ivec3(rayPos.x + rayPos.y * texSize, rayPos.z, materialIndex), gs_voxel_material_mipmap.z).xy;
		while((codes.y & voxelMask) == 0)
		{
			if(d.x < d.y || d.z < d.y) {
				if(d.x < d.z) {
					rayPos.x += dirSign.x;
					d.yz -= d.x;
					d.x = projLength.x;
				} else {
					rayPos.z += dirSign.z;
					d.xy -= d.z;
					d.z = projLength.z;
				}
			} else {
				rayPos.y += dirSign.y;
				d.xz -= d.y;
				d.y = projLength.y;
			}
			if(any(greaterThanEqual(rayPos, ivec3(texSize,texSize,texSize))) || any(lessThan(rayPos, ivec3(0,0,0))))
				discard;
			codes = texelFetch(u_componentTex, ivec3(rayPos.x + rayPos.y * texSize, rayPos.z, materialIndex), gs_voxel_material_mipmap.z).xy;
		}
	}
	
	// Estimate normal from the plane we intersected
	d = abs(d - projLength);
	vec3 normal;
	if(d.x < 0.0001) normal = -dirSign.x * vec3(c_mWorldView[0][0], c_mWorldView[1][0], c_mWorldView[2][0]);
	if(d.y < 0.0001) normal = -dirSign.y * vec3(c_mWorldView[0][1], c_mWorldView[1][1], c_mWorldView[2][1]);
	if(d.z < 0.0001) normal = -dirSign.z * vec3(c_mWorldView[0][2], c_mWorldView[1][2], c_mWorldView[2][2]);
	normal = normalize(normal);
	
	// Decode transparency or color rotation
	float yvar = float((codes.x >> 28) & 0xf) / 15.0;

	// Decode rgb color from material
	float color_y  = float(codes.x & 0xff) / 255.0;
	
	float phase = mod(hash(rayPos.x + rayPos.y * 8 + rayPos.z * 64), 6283) * 0.001;
	color_y *= (sin(c_fTime * 3.0 + phase) * 0.5 + 0.5) * yvar + 1 - yvar;
	float color_pb = (float((codes.x >> 18) & 0x1f) - 15.0) / 255.0;
	float color_pr = (float((codes.x >> 23) & 0x1f) - 15.0) / 255.0;
	vec3 color = vec3(color_y + 0.22627 * color_pb + 11.472 * color_pr,
					color_y - 3.0268 * color_pb - 5.8708 * color_pr,
					color_y + 14.753 * color_pb + 0.0082212 * color_pr);
	//color = min(vec3(1,1,1), max(vec3(0,0,0), color));

	// Decode other material parameters
	float shininess = float((codes.x >> 12) & 0xf) / 15.0;
	// Use code as power of to and compute: (2^spec) * 3
	float specular = (1 << ((codes.x >> 8) & 0xf)) * 3.0;
	float emissive = float((codes.x >> 17) & 1);
	
	fragColor.xyz = Lightning(normal, -viewDir, shininess, specular, color, emissive);
	fragColor.a = 1;
}
